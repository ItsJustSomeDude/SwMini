import com.android.build.gradle.tasks.ExternalNativeBuildJsonTask

import java.nio.file.Files
import java.nio.file.StandardCopyOption

plugins {
	alias(libs.plugins.android.application)
}

android {
	namespace = 'net.itsjustsomedude.swrdg'
	compileSdk = 36
	ndkVersion = "29.0.14206865"

	buildFeatures {
		prefab = true
		buildConfig = true
	}

	defaultConfig {
		applicationId 'net.itsjustsomedude.swrdg'
		minSdk = 24
		targetSdk = 36
		versionCode 46
		versionName '1.4.10'
	}

	externalNativeBuild {
		cmake {
			path "src/main/cpp/CMakeLists.txt"
		}
	}

	sourceSets {
		main {
			jniLibs.srcDirs = ['src/main/jniLibs']
		}
	}

	signingConfigs {
		// This is configured at the bottom of the file.
		release {}
	}

	buildTypes {
		release {
			signingConfig = signingConfigs.release
			minifyEnabled = false
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

			vcsInfo.include = false

			ndk {
				// noinspection ChromeOsAbiSupport
				abiFilters "armeabi-v7a", "arm64-v8a"
			}
		}
		debug {
			signingConfig = signingConfigs.release
			debuggable true
			minifyEnabled false

			ndk {
				// noinspection ChromeOsAbiSupport
				abiFilters "armeabi-v7a", "arm64-v8a"
			}
		}
		debug32 {
			initWith debug

			ndk {
				abiFilters.clear()
				//noinspection ChromeOsAbiSupport
				abiFilters 'armeabi-v7a'
			}
		}
	}

	compileOptions {
		sourceCompatibility JavaVersion.VERSION_11
		targetCompatibility JavaVersion.VERSION_11
	}

	packaging {
		jniLibs {
			// Legacy Packaging completely breaks stack traces.
			useLegacyPackaging true
		}
	}

	applicationVariants.configureEach { /* com.android.build.gradle.internal.api.ApplicationVariantImpl */ variant ->
		variant.outputs.configureEach { output ->
			if (variant.buildType.name == "release") {
				def appName = "SwordigoMini"
				def versionName = variant.versionName
				def versionCode = variant.versionCode
				outputFileName = "${appName}_${versionName}_${versionCode}.apk"
			}
		}

		// TODO: Create a "mergeMiniAssets" task that does this and the Readme thing.
		variant.mergeAssetsProvider.get().doLast {
			File outputDir = it.outputDir.getAsFile().get()

			// Ok, so we need to merge the `mini_resources` contents into the `resources` folder,
			// then delete `mini_res_src` and `mini_resources`.

			File resourcesDir = new File(outputDir, "resources")
			File compiledRes = new File(outputDir, "res")

			if (compiledRes.exists() && compiledRes.isDirectory() && resourcesDir.exists() && resourcesDir.isDirectory()) {
				File gitignore = new File(compiledRes, ".gitignore")
				if (gitignore.exists()) {
					delete(gitignore)
				}

				copy {
					from compiledRes
					into resourcesDir
				}
			}

			File miniResSrcDir = new File(outputDir, "mini_resources")
			if (miniResSrcDir.exists()) {
				delete(miniResSrcDir)
			}

			if (compiledRes.exists()) {
				delete(compiledRes)
			}

			// Delete the .gitignore from the Rocks folder.
			File rocksFolder = new File(outputDir, "rocks")
			File rocksIgnore = new File(rocksFolder, ".gitignore")
			if (rocksIgnore.exists()) {
				delete(rocksIgnore)
			}
		}
	}
}

dependencies {
	implementation files('libs/renderer.jar')
	implementation 'io.github.wasabithumb:jtoml:1.4.2'
}

androidComponents {
	onVariants(selector().withBuildType("debug32")) {
		packaging.jniLibs.excludes.add("/lib/arm64-v8a/*.so")
	}
}

tasks.register("copyGlossHook") {
	doLast {
		def glossSource = file("../GlossHook/GlossHook/lib")
		def destLibs = file("src/main/jniLibs")

		if (!glossSource.exists()) {
			throw new GradleException("GlossHook directory not found! Make sure the git submodules were included.")
		}

		println("Copying GlossHook from ${glossSource.absolutePath} to ${destLibs.absolutePath}.")

		def dest32 = file("${destLibs}/armeabi-v7a")
		def dest64 = file("${destLibs}/arm64-v8a")
		dest32.mkdirs()
		dest64.mkdirs()

		Files.copy(file("${glossSource}/ARM/libGlossHook.so").toPath(), file("${dest32}/libGlossHook.so").toPath(), StandardCopyOption.REPLACE_EXISTING)
		Files.copy(file("${glossSource}/ARM64/libGlossHook.so").toPath(), file("${dest64}/libGlossHook.so").toPath(), StandardCopyOption.REPLACE_EXISTING)
	}
}

tasks.register("copyReadme") {
	doLast {

		Files.copy(
			file("../README.md").toPath(),
			file("src/main/assets/README_MINI").toPath(),
			StandardCopyOption.REPLACE_EXISTING
		)
	}
}

afterEvaluate {
	tasks.withType(JavaCompile).configureEach {
		options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
	}

	tasks.withType(ExternalNativeBuildJsonTask).tap {
		configureEach {
			it.dependsOn copyGlossHook
			it.dependsOn copyVanillaLibs

			// This should be before Assets, but this is fine for now.
			it.dependsOn extractVanilla
		}
	}

	tasks.withType(JavaCompile).tap {
		configureEach {
			it.dependsOn copyVanillaClasses
		}
	}
}

// Load sensitive values only from ~/.gradle/gradle.properties or <project>/local.properties
def home = System.properties['user.home']
def localPropertiesFile = rootProject.file("local.properties")
def localProperties = new Properties()
if (localPropertiesFile.exists()) {
	localProperties.load(new FileInputStream(localPropertiesFile))
} else {
	// Fallback to user's home .gradle/gradle.properties (never commit)
	def globalPropsFile = file("${home}/.gradle/gradle.properties")
	if (globalPropsFile.exists()) {
		localProperties.load(new FileInputStream(globalPropsFile))
	}
}

if (localProperties.containsKey('KEYSTORE_PASSWORD')) {
	android.signingConfigs.release {
		storeFile file(localProperties['KEYSTORE_PATH'])
		storePassword localProperties['KEYSTORE_PASSWORD']
		keyAlias localProperties['KEY_ALIAS']
		keyPassword localProperties['KEY_PASSWORD']
		enableV1Signing = true
		enableV2Signing = true
		enableV3Signing = true
	}
}

apply from: 'extractor.gradle'
